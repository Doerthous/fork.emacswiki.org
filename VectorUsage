Usually you should not be trying to modify vectors themselves, only the elements stored in the vector, because vectors are designed for ''random access''.  They are fast.  They are not designed to be searched or sorted.  They are also immutable, so you cannot change them (only the elements).  If you want change them (change their size), you must create a copy instead.

In Emacs 28.1, you can type `M-x shortdoc-display-group RET vector RET' for an overview of what you can do.

You can also use the seq.el package instead, included in a recent Emacs or installable from GNU ELPA, for many common operations.

== Sorting/Randomizing/Shuffling ==

    (defun shuffle-vector (vector)
      "Randomly permute the elements of VECTOR (all permutations equally likely)."
      (let ((i 0)
    	j
    	temp
    	(len (length vector)))
        (while (< i len)
          (setq j (+ i (random (- len i))))
          (setq temp (aref vector i))
          (aset vector i (aref vector j))
          (aset vector j temp)
          (setq i (1+ i))))
      vector)

Example output:

    [1 5 3 2 4]
    [3 2 5 1 4]
    [3 4 1 5 2]

= Searching Vectors for Values =

You can search lists using `member' or `memq', and you can search alists using `assoc' and `assq'.

Here is how to search a vector for a value:

    (cl-position 'c [a b c])
    => 2

`cl-position' is a function from the CL-Lib package.  You need to require it (or require package CL at byte-compile time -- see next):

    (require 'cl-lib)

Here is how to search a vector `v' for a value `b' using the loop macro.
This may be more useful if you need to do things with the elements as you
search.

    (let ((v [4 5 6 7 8])
          (b 7))
      (cl-loop for i from 0 for a across v if (equal a b) return i))
     => 3



== Using CL Functions Without Bothering with Prefix `cl-' ==

Library ##cl.el## contains macros that alias `case' to `cl-case', `loop' to `cl-loop', `position' to `cl-position', and so on -- nearly all the `cl-' functions.  If you like, you can take advantage of this, using only the unprefixed names in your code, just by doing this:

    (eval-when-compile (require 'cl))

Unless you really need library ##cl-lib.el## (or ##cl.el##) at runtime for some reason, that's all you need.



== Library Ring+ ==

DrewAdams has written library Lisp:ring+.el, which extends standard library <code>ring.el</code> to provides feature for using vectors as cyclic structures ("rings"). See RingPlus. 

This library includes function `ring-convert-sequence-to-ring', which converts any sequence to a ring, which is a vector. A '''sequence''' is any of these:

* list
* array, which is any of these:
** string
** vector
** char-table (like a vector, but indexed by character codes)
** bool-vector (like a vector, but with only `t' and `nil' entries)




== A Gotcha! ==

Don't try to treat an [[obarray]] as a normal vector!  The [[Manual:Creating Symbols|Elisp manual]] tells you this clearly, but I nevertheless tried to do this (programming idiom pointed out in the discussion of vectors in the same manual):

  (setq my-list (append minibuffer-completion-table nil)) ; Convert vector to list.

'''''Wrong!''''' And it took me while to figure the problem out...

When dealing with obarrays, use `mapatoms' -- always.   -- DrewAdams



== See Also ==

* LevenshteinDistance - Uses vectors for determining the edit distance between two strings.

For more info on sequences, see the Elisp manual, Info node '''Sequences Arrays Vectors'''.

----
CategoryCode
