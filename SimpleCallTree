This package creates a call-tree for a single buffer -- a data structure saying which
function calls which function within the buffer .

* Lisp:simple-call-tree.el

Use `M-x simple-call-tree-analyze' to run it on a buffer.  This uses
`font-lock-function-name' to identify function names and sets `simple-call-tree-alist', which maps callers to their callees, with the callees represented as a list.  Callers without callees are included.

Gotcha: Each caller or callee is represented in the alist as a singleton list containing a string (with properties) rather than as a string.  See `plain-call-tree' below for a way to flatten these. 

==Basic use==
# open the buffer you want to analyze
# ensure it's fontified, e.g. call `font-lock-fontify-buffer' 
# call `simple-call-tree-analyze'
# use other functions (in the package, below, your own ...) to process `simple-call-tree-alist'

== Pretty Printing ==

After calling `simple-call-tree-analyze', the function below can be used to list callers and callees in a buffer:

<pre>
(defun simple-call-tree-list-callers-and-functions ()
  "List callers and functions in `simple-call-tree-alist'."
  (interactive)
  (let ((list simple-call-tree-alist))
    (switch-to-buffer (get-buffer-create "*simple-call-tree*"))
    (erase-buffer)
    (dolist (entry list)
      (let ((functions (mapconcat #'car (cdr entry) ", ")))
        (insert (caar entry) " calls "
                (if (string= functions "")
                    "no functions"
                  functions)
                ".\n")))))
</pre>
== Visualization ==
One way to visualize using http://www.graphviz.org/ is below.  This could be adapted, e.g. called from an OrgMode buffer.

Prerequisites
# install graphviz
# ensure `sct-dot' (see below) is defined

Usage
# open the buffer you want to analyze
# ensure it's fontified, e.g. call `font-lock-fontify-buffer' 
# call `simple-call-tree-analyze'
# switch to an empty buffer
# evaluate `(insert (sct-dot))'
# you can then save the buffer and use graphviz's dot to visualize it

<pre>
(defun sct-dot ()
  "Generate dot file for graphviz from `simple-call-tree-alist'.

After calling `simple-call-tree-analyze', use `sct-dot' in an
empty buffer via `(insert (sct-dot))'.

Then save the file as \"my-file.dot\" and run
\"dot -Tjpg /path/to/my-file.dot -o result.jpg\" from command line."
  (concat "digraph G {\n" ;; default beginning of a dot file
          (mapconcat 'identity ;; end each line with a ";"
                     (mapcar
                      (lambda (defun-list)
                        "Called for each element (list) of `simple-call-tree-alist',
                         create all the 'caller -> callee;' strings."
                        (let ((caller (caar defun-list))
                              (callees (cdr defun-list)))
                          (if (null callees)
                              (concat "\"" caller "\"")
                            (mapconcat (lambda (callee)
                                         "Called with each callee, create 'caller -> callee' pairs."
                                         (concat "\"" caller "\"" " -> " "\"" (car callee) "\""))
                                       callees
                                       ";\n"))))
                      simple-call-tree-alist)
                     ";\n")
          ";\n}"))
</pre>

==Simplifying simple-call-tree-alist==
The function below can be used to convert `simple-call-tree-alist' to a simpler form using strings rather than singleton lists of strings.  
<pre>
(defun plain-call-tree ()
  "Return an alist of callers to callees based on
`simple-call-tree-alist' in which each caller is a plain string and the
callees are lists of plain strings."
  
  (mapcar
   (lambda (caller-callees)
     (mapcar (lambda (func-list)
                     (substring-no-properties (car func-list)))
             caller-callees))
   simple-call-tree-alist))
</pre>
== Use with Helm ==
See [https://github.com/qilicun/emacs.d/blob/master/site-lisp/helm/helm-call-tree.el helm-call-tree.el] for one integration (I have not tested this). 

==simple-call-tree+.el==

The following library is based on simple-call-tree.el and provides a major mode for
displaying and navigating the call tree. You can invert the tree, change the depth,
narrow to a particular branch, perform query replacements on functions (useful for refactoring),
and it also works with follow mode if you have that installed (http://www.damtp.cam.ac.uk/user/sje30/emacs/fm.el).

Feel free to help develop it further, here is the github page: https://github.com/vapniks/simple-call-tree-ext

* Lisp:simple-call-tree+.el

-- JoeBloggs

----
CategoryCode CategoryProgrammerUtils CategoryNavigation
