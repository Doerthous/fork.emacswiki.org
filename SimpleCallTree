There are two major versions of this package.  Both create a call-tree for a single buffer -- a data structure saying which
functions are called by each function in the buffer.

The first major version was created by Alex Schroder as simple-call-tree.el c. 2003.  Its code is short (138 lines) and is available at
* Lisp:simple-call-tree-original.el

The second major version was created by GitHub user vapniks, originally as simple-call-tree-ext, now renamed simple-call-tree, described as thus: "is based on simple-call-tree.el and provides a major mode for displaying and navigating the call tree. You can invert the tree, change the depth, narrow to a particular branch, perform query replacements on functions (useful for refactoring), and it also works with follow mode if you have that installed (http://www.damtp.cam.ac.uk/user/sje30/emacs/fm.el)." Its code is much longer than the original (over 2000 lines of code) and versions of it are available at 
* Lisp:simple-call-tree+.el
* Lisp:simple-call-tree.el
* https://github.com/vapniks/simple-call-tree
* https://melpa.org/#/simple-call-tree

Basic use for both versions is as below.  Both versions set `simple-call-tree-alist', which maps callers to their callees, with the callees represented as a list.  Callers without callees are included.

There are some helper functions below written for the original simple-call-tree.  They are incompatible with vapniks's version, in which each caller or callee is represented in the alist as a singleton list containing a string (with properties) rather than as a plain string.  See `plain-call-tree' below for a way to flatten these to the form used by the original simple-call-tree. 

==Basic use==
# open the buffer you want to analyze
# ensure it's fontified, e.g. call `font-lock-fontify-buffer' 
# call `simple-call-tree-analyze'
# use other functions (in the package, below, your own ...) to process `simple-call-tree-alist'

== Pretty Printing ==
After calling `simple-call-tree-analyze', the function below can be used to list callers and callees in a buffer:

<pre>
(defun simple-call-tree-list-callers-and-functions ()
  "List callers and functions in `simple-call-tree-alist'."
  (interactive)
  (let ((list simple-call-tree-alist))
    (switch-to-buffer (get-buffer-create "*simple-call-tree*"))
    (erase-buffer)
    (dolist (entry list)
      (let ((functions (mapconcat #'identity (cdr entry) ", ")))
        (insert (car entry) " calls "
                (if (string= functions "")
                    "no functions"
                  functions)
                ".\n")))))
</pre>
== Visualization ==
One way to visualize using http://www.graphviz.org/ is below.  This could be adapted, e.g. called from an OrgMode buffer.

Prerequisites
# install graphviz
# ensure `sct-dot' (see below) is defined

Usage
# open the buffer you want to analyze
# ensure it's fontified, e.g. call `font-lock-fontify-buffer' 
# call `simple-call-tree-analyze'
# switch to an empty buffer
# evaluate `(insert (sct-dot))'
# you can then save the buffer and use graphviz's dot to visualize it

<pre>
(defun sct-dot ()
  "Generate dot file for graphviz from `simple-call-tree-alist'.

After calling `simple-call-tree-analyze', use `sct-dot' in an
empty buffer via `(insert (sct-dot))'.

Then save the file as \"my-file.dot\" and run
\"dot -Tjpg /path/to/my-file.dot -o result.jpg\" from command line."
  (concat "digraph G {\n" ;; default beginning of a dot file
          (mapconcat 'identity ;; end each line with a ";"
                     (mapcar
                      (lambda (defun-list)
                        "Called for each element (list) of `simple-call-tree-alist',
                         create all the 'caller -> callee;' strings."
                        (let ((caller (car defun-list))
                              (callees (cdr defun-list)))
                          (if (null callees)
                              (concat "\"" caller "\"")
                            (mapconcat (lambda (callee)
                                         "Called with each callee, create 'caller -> callee' pairs."
                                         (concat "\"" caller "\"" " -> " "\"" callee "\""))
                                       callees
                                       ";\n"))))
                      simple-call-tree-alist)
                     ";\n")
          ";\n}"))
</pre>

==Flattening simple-call-tree-alist to plain form ==
The function below can be used to convert `simple-call-tree-alist' as created by simple-call-tree-ext to one compatible with the original simple-call-tree.  
<pre>
(defun plain-call-tree ()
  "Convert `simple-call-tree-alist' to the format used in the original package."
  
  (mapcar
   (lambda (caller-callees)
     (mapcar (lambda (func-list)
                     (substring-no-properties (car func-list)))
             caller-callees))
   simple-call-tree-alist))
</pre>
----
CategoryCode CategoryProgrammerUtils CategoryNavigation
