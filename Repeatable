A repeatable command can be called again by repeatedly hitting (or just holding down) the last key stroke/chord.

For example: You can call the repeatable command `kmacro-end-and-call-macro' (bound to `C-x e') repeatedly -- the first
time with `C-x e' and with only `e' subsequently. After you press another
key, things are back to normal.

But you cannot call the non-repeatable command `transpose-lines' (bound to `C-x C-t' repeatedly. That is, you cannot use `C-x C-t C-t C-t'..., holding `C-t' pressed, to repeat the action of transposing lines.




== Simple Code To Make a Command Repeatable ==

{{{
(defun repeat-command (command)
  "Repeat COMMAND."
  (require 'repeat)
  (let ((repeat-previous-repeated-command  command)
        (repeat-message-function           #'ignore)
        (last-repeatable-command           'repeat))
    (repeat nil)))
}}}

Given an ordinary, non-repeatable command `foo', just do this to get a repeatable one:


{{{
(defun repeatable-foo (arg) ; or whatever other arguments
  "whatever..."
  (interactive "P") ; or whatever else
  (repeat-command 'foo)
}}}

I use this in several of my libraries: [[Bookmark+]], [[Zones]], [[Isearch+]], [[Icicles]], <tt>[[misc-cmds.el]]</tt>, [[thing-cmds.el]]</tt>. -- DrewAdams


== Simple code to make EVERY command repeatable ==

This makes all key-bindings repeatable even "single"-key shortcuts like `C-f' or `M-C-f' (both repeated by subsequent `f'). Stuff like `C-x o' is repeated with `o' and
`C-x C-@' repeats with `@'. There is no need to explicitly configure functions or shortcuts to make them repeatable, because this works on all commands. On the other hand, there is no option to (easily) configure exceptions. So far this wasn't a Problem for me.

{{{
(defun easy-repeat ()
  "Repeat last command by typing it's last key again or pressing SPC"
  (interactive)
  (let* ((com this-command)
	 (case-fold-search nil)
	 (keys (recent-keys))
	 (key (aref keys (1- (length keys))))
	 (key-str (if (or (integerp key) (symbolp key) (listp key))
		      (single-key-description key)
		    nil))
	 (last (cond ((= (length key-str) 1) key-str)
		     ((string-match "^<[a-z]*>$" key-str) key-str)
  		     ((setq i (string-match "-.*>$" key-str)) (concat "<" (substring key-str (1+ i))))
		     ((setq i (string-match "-.*$" key-str)) (substring key-str (1+ i)))
		     (t (char-to-string (aref key-str (1- (length key-str)))))))
	 (map (make-sparse-keymap)))
    (define-key map (kbd last) com)
    (if (eq this-command 'self-insert-command)
	(global-set-key (kbd "n") 'self-insert-command)
      (set-transient-map map t))))
(add-hook 'post-command-hook 'easy-repeat)

}}}


== Packages To Make a Command Repeatable ==

* [[Hydra]]
* ##repeatable.el##
** [[http://furius.ca/pubcode/pub/conf/lib/elisp/blais/repeatable.el|repeatable.el]] - `defadvice'-based implementation
** [[https://github.com/leoliu/repeatable.el|repeatable.el]] - An `fset' + `set-transient-map'-based implementation (Emacs 24+)





----
CategoryCommands
